/**
 * @author chensj
 * @classDesc google protobuf RPC 框架
 * @project java-netty-module
 * @version v1.0
 * @email chenshijie1988@yeah.net
 * @date 2019-07-12 21:02
 * RMI Remote Method Invocation，只针对Java 远程方法执行调用
 * 底层都是基于socket通信的。对于多数的RPC框架，都包含了代码生成的部分，
 * 代码的生成中包含了对象的序列化和反序列化、服务之间数据的传输
 * 这两者别称就是如下：
 * client： stub
 * server： skeleton
 *
 * client通过序列化将数据编码，传输给stub，stub通过socket将信息传输给skeleton，skeleton会反序列化数据，解码为server可以识别的语言
 *
 * 序列化与反序列化 也可以称之为编码与解码
 *
 * RPC Remote Procedure Call 远程过程调用
 * 原理与RMi基本一样的，但是RPC框架多数都是跨语言的，这也是RPC的优势所在
 *
 * 开发模式：
 * 1、定义一个接口说明文件(IDL): 说明如下信息
 *      描述了对象(结构体)、对象成员、接口方法等一系列信息
 *    这是一个文本文件，独立于语言的
 * 2、通过RPC框架所提供的编译器，将接口说明文件编译成具体的语言文件
 *
 * 3、在客户端与服务端分别引入RPC编译器生成的文件，即可像调用本地方法一样调用远程方法
 *
 * 指南：
 *  java 序列化或反序列化 结构化数据方式有以下三种模式：
 *    1、Java 语言自带的序列化，这也是默认的序列化方式，但是这种方式存在许多已知的问题，
 *      在跨语言数据共享方面（C++和python）表现并不是很好，序列化机制与其他语言并不兼容
 *    2、 自定义编解码的序列化：一种特殊的方法将数据项编码为单个字符串，例如将4个整数编码为"12:3:-23:67"。
 *      这是一种简单而灵活的方法，虽然它确实需要编写一次性编码和解析代码，并且解析会产生较小的运行时成本。
 *      这也是最适合编码非常简单的数据。
 *    3、XML方式：将数据序列化为XML，这种方法非常有吸引力，因为XML数据是人类可读的，并且有许多语言提供了解析库。
 *    如果你需要与其他应用共享数据，这也是很好地一种方式、但是xml是一种非常占用空间和消耗性能的方式，并且在遍历xml dom
 *    树也是非常麻烦的
 * Protocol Buffer：  灵活，高效，自动化的解决方案，可以解决上述这个问题。通过创建一个.proto的数据结构说明文件，
 * 这个文件用来存储数据，通过这个文件，通过编译器将这个文件来进行编码和解码，生成class文件，并提供向前兼容的方式
 */
package org.chen.architect.google.protobuf;
